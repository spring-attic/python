//tag::ref-doc[]
== Python Local Processor
:imagesdir: ../images
:python-springcloudstream: https://pypi.python.org/pypi/springcloudstream


A processor application that starts an external Python process in the local container, sends message payloads to it and
receives the results via a tcp pipe. The process must define a function with a single `<str>` argument that returns a `<str>`.
By default the tcp connection is configured for text with `\n` or `\r\n` delimiters.
However you can set the encoder to `BINARY` to use `pickle` serialization for example.
The binary encoder uses `x1a` as the string terminator. For convenience you can import
the {python-springcloudstream}[springcloudstream] module to handle the low level I/O.




[NOTE]
====
If you are running on Cloud Foundry, you need to use the link:../docs/JavaPythonBuildPack.adoc[Java Python buildpack].
Or if deploying as a Docker image, use one of the of the java-python images https://hub.docker.com/u/korekontrol/[here].
====

For local file system scripts (including a Git clone), if `requirements.txt` exists in the base directory,
the application will `pip install` any Python dependencies during start up. If using Conda, the virtual environment must
be configured and active. If the app is running in CloudFoundry, the Java Python buildpack will configure any Python
dependencies.

Here's an example that works with the `time-source` stream app:

=== The Script

time-transformer.py
[source,python]
----
from datetime import datetime
from springcloudstream.stream import Processor

#06/01/16 09:45:11
def time_delta(data):
	format = '%m/%d/%y %H:%M:%S'
	delta = datetime.now() - datetime.strptime(data,format)
	return str(delta)

process = Processor()
process.start(time_delta)
----

[NOTE]
====
Currently I/O is bound to `stdin` an `stdout` so any prints will cause problems. We're working on an option to use available ports.
====

Since you are importing `springcloudstream`, you need to provide `requirements.txt` in the top level directory with an entry for `springcloudstream` minimally.

=== Jython Wrapper

If you need to convert types to and from `<str>`, you may optional configure a Jython wrapper. JSon should work well in
most cases, but if you want to pickle something, its best to stick with standard types such as `<dict>`, `<tuple>`, etc.
Pickling user defined objects between Jython and native Python has some known issues, but YMMV.

The Jython wrapper uses a simple convention illustrated by this example: 

pickle-page.py
[source,python]
----
import cPickle as pickle
import json
from java.lang import String

'''
Map to a Python object
'''


class Page:
    def __init__(self, page):
        self.links = {}
        for key in page.links:
            self.links[key] = page.links[key].toString()
        self.images = {}
        for key in page.images:
            self.images[key] = page.images[key]



'payload is bound to Java Page object`
page = Page(payload)

'Pickle the Page <dict>'
input = pickle.dumps(page.__dict__, protocol)

'The processor variable is bound to ShellProcessor. Invoke the shell processor and receive a dict'
data = processor.sendAndReceive(input)

'deserialize'
returned_page = pickle.loads(data)

'transform to java String as Json'
result = String(json.dumps(returned_page))
----

[NOTE]
----
The last line in the script must be an assignment statement. The variable name doesn't matter. This is required to bind the return value correctly.
----


Page.java
[source, java]
----
public class Page {
	private Map<String, Object> links = new HashMap<>();
	private Map<String,Object> images = new HashMap<>();

	public Map<String, Object> getLinks() {
		return links;
	}

	public void setLinks(Map<String, Object> links) {
		this.links = links;
	}

	public Map<String, Object> getImages() {
		return images;
	}

	public void setImages(Map<String, Object> images) {
		this.images = images;
	}
}

----

The `pickle-page.py` wrapper transforms the input prior to invoking `processor.sendAndReceive`. This is the Java `ShellProcessor` that calls the external Python app. It is always bound to the variable named `processor`. Then the script transforms the output to a JSON string, which will be consumed by the next app in the stream.   

See link:../docs/JavaPythonBuildPack.adoc[Deploying to Cloud Foundry]

{nbsp}

image:python-local-procesor.gif[LocalProcessor]

== Options

The **$$python-local$$** $$processor$$ has the following options:



//tag::configuration-properties[]
$$git.basedir$$:: $$The base directory where the repository should be cloned. If not specified, a temporary directory will be
 created.$$ *($$File$$, default: `$$<none>$$`)*
$$git.clone-on-start$$:: $$Flag to indicate that the repository should be cloned on startup (not on demand).
 Generally leads to slower startup but faster first query.$$ *($$Boolean$$, default: `$$true$$`)*
$$git.label$$:: $$The label or branch to clone.$$ *($$String$$, default: `$$master$$`)*
$$git.passphrase$$:: $$The passphrase for the remote repository.$$ *($$String$$, default: `$$<none>$$`)*
$$git.password$$:: $$The password for the remote repository.$$ *($$String$$, default: `$$<none>$$`)*
$$git.timeout$$:: $$Timeout (in seconds) for obtaining HTTP or SSH connection (if applicable). Default
 5 seconds.$$ *($$Integer$$, default: `$$5$$`)*
$$git.uri$$:: $$The URI of the remote repository.$$ *($$String$$, default: `$$<none>$$`)*
$$git.username$$:: $$The username for the remote repository.$$ *($$String$$, default: `$$<none>$$`)*
$$python.args$$:: $$The Python command line args.$$ *($$String$$, default: `$$<empty string>$$`)*
$$python.basedir$$:: $$The root path of Python app. If given, the script path must be relative to this location.$$ *($$FileSystemResource$$, default: `$$<none>$$`)*
$$python.command-name$$:: $$The python command name, e.g., 'python', 'python3'.$$ *($$String$$, default: `$$python$$`)*
$$python.pip-command-name$$:: $$The pip command name, e.g., 'pip', 'pip3'.$$ *($$String$$, default: `$$pip$$`)*
$$python.script$$:: $$The Python script file name.$$ *($$String$$, default: `$$<none>$$`)*
$$wrapper.delimiter$$:: $$The variable delimiter.$$ *($$Delimiter$$, default: `$$<none>$$`, possible values: `COMMA`,`SPACE`,`TAB`,`NEWLINE`)*
$$wrapper.script$$:: $$The Python script file name.$$ *($$String$$, default: `$$<none>$$`)*
$$wrapper.variables$$:: $$Variable bindings as a delimited string of name-value pairs, e.g. 'foo=bar,baz=car'.$$ *($$String$$, default: `$$<none>$$`)*
//end::configuration-properties[]

$$python.contentType$$:: $$The output contentType, e.g., application/json.$$ *($$String$$, default: `$$<none>$$`)*

== Build

[source, bash]
----
$./mvnw package
----
//end::ref-doc[]
