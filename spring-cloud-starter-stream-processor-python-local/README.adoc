# spring-cloud-stream-processor-python-local
:imagesdir: ../images
:python-springcloudstream: https://pypi.python.org/pypi/springcloudstream


Spring Cloud Stream App Starters for integrating with python

This component starts a local Python process in the local container, sends message payloads to it and receives the results via a tcp pipe. The process must define a function with a single `<str>` argument that returns a `<str>`. By default the tcp connection is configured for text with `\n` or `\r\n` delimiters. However you can set the encoder to `BINARY` to use `pickle` serialization for example. The binary encoder uses `x1a` as the string terminator. For convenience you can import {python-springcloudstream}[springcloudstream] module to handle the low level I/O. Here's an example that works with the `time-source` stream app:

## The Script

time-transformer.py
[source,python]
----
from datetime import datetime
from springcloudstream.stream import Processor

#06/01/16 09:45:11
def time_delta(data):
	format = '%m/%d/%y %H:%M:%S'
	delta = datetime.now() - datetime.strptime(data,format)
	return str(delta)

process = Processor()
process.start(time_delta)
----

[NOTE]
====
Currently I/O is bound to `stdin` an `stdout` so any prints will cause problems. We're working on an option to use available ports.
====

Since you are importing `springcloudstream`, you need to provide `requirements.txt` in the top level directory with an entry for `springcloudstream` minimally.

## Jython Wrapper

If you need to convert types to and from `<str>`, you may configure a Jython wrapper. JSon should work well in most cases, but if you want to pickle something, its best to stick with standard types such as `<dict>`, `<tuple>`, etc. Pickling user defined objects between Jython and native Python has some known issues, but YMMV. 

The Jython wrapper uses a simple convention illustrated by this example: 

pickle-page.py
[source,python]
----
import cPickle as pickle
import json
from java.lang import String

'''
Map to a Python object
'''


class Page:
    def __init__(self, page):
        self.links = {}
        for key in page.links:
            self.links[key] = page.links[key].toString()
        self.images = {}
        for key in page.images:
            self.images[key] = page.images[key]



'payload is bound to Java Page object`
page = Page(payload)

'Pickle the Page <dict>'
input = pickle.dumps(page.__dict__, protocol)

'The processor variable is bound to ShellProcessor. Invoke the shell processor and receive a dict'
data = processor.sendAndReceive(input)

'deserialize'
returned_page = pickle.loads(data)

'transform to java String as Json'
result = String(json.dumps(returned_page))
----

[NOTE]
----
The last line of the script must be an assignment statement to correctly bind the return value.
----


Page.java
[source, java]
----
public class Page {
	private Map<String, Object> links = new HashMap<>();
	private Map<String,Object> images = new HashMap<>();

	public Map<String, Object> getLinks() {
		return links;
	}

	public void setLinks(Map<String, Object> links) {
		this.links = links;
	}

	public Map<String, Object> getImages() {
		return images;
	}

	public void setImages(Map<String, Object> images) {
		this.images = images;
	}
}

----

The `pickle-page.py` wrapper transforms the input prior to invoking `processor.sendAndReceive`. This is the Java `ShellProcessor` that calls the external Python app. It is always bound to the variable named `processor`. Then the script transforms the output to a JSON string, which will be consumed by the next app in the stream.   

See link:../docs/JavaPythonBuildPack.adoc[Deploying to Cloud Foundry]

{nbsp}

image:python-local-procesor.gif[LocalProcessor]
